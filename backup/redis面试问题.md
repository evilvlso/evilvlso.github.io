# 快的原因

1. 基于内存实现的
2. 采用io多路复用模型。非阻塞io ,epoll+自己的时间循环机制
3. 单线程模型，避免不必要的上下文切换和资源竞争
4. 高效的底层数据结构

https://mp.weixin.qq.com/s/3V_ziL_l6dCCzQz9cOmiHQ 不错

## 缓存穿透
描述：查询一个数据库不存在的数据，不会去缓存，压力直接给到数据库
解决方案：
1. 将不存的数据也进行缓存，单过期时间设置较短些
2.使用布隆过滤器，存储可能存在的数据，先在过滤器中查询是否存在在去判断是否请求数据库。布隆过滤器特点: 存在的不一定存在，不存在的一定不存在。
## 缓存击穿
描述：对于一些过期的数据，短时间有大量请求，会直接对数据库造成压力
解决方案：
1. 使用互斥锁。大量并发请求请求到缓存时，使用`setnx`命令返回结果为true在去数据库请求。`setnx key value`:如果不存在则设置为value，也就意味着其中一个请求拿到了锁,其他请求就不会请求db了
2. 设置用不过期
## 缓存雪崩
描述：大量数据同一时间过期
解决方案:
1. 将过期时间离散开来

##  redis默认16个db
## redis删除策略
1. 定时删除。设定过期时间，到时间久删除
2. 惰性删除。设定过期时间，到时间先不删除，等到有请求访问在删除。
3. 定期删除。隔一段时间删除一批。

## redis vs memcached
1. redis支持更多的数据结构，memcached只支持k-v数据结构
2. redis可以对k设置过期时间
缺点：瓶颈在物理内存的大小 而非cpu，使用前需要评估内存是否充足

## 为什么要使用缓存
保证服务的高性能和高并发

## 缓存同步方案
1. 同步方案。从业务代码层面，更新完数据可就对缓存进行更新
2. 异步方案。将更新的数据放入消息队列中，消费者从消息队列进行更新

## redis的集群方案
1. 主从模式。
    保证高可用；无法实现故障转移；无法实现海量数据存储
2. 哨兵模式
    高可用；可以自动实现故障转移；无法实现海量数据存储
3. 分片集群
    高可用；可以自动转移故障；可以实现海量数据存储

## redis事务
MULTI 开启事务；EXEC执行事务；
![image-20220711104209304](https://raw.githubusercontent.com/evilvlso/picsbed/master/image-20220711104209304.png)

## redis内存优化

尽可能使用散列表(Hash)。比如你的 web 系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面。

## 如何保持mysql和redis数据一致性

<img src="https://raw.githubusercontent.com/evilvlso/picsbed/master/image-20220718174349186.png" alt="image-20220718174349186" style="zoom:50%;" />