<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>tango</title><link>https://evilvlso.github.io</link><description>just tango </description><copyright>tango</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://avatars.githubusercontent.com/u/25767862?v=4</url><title>avatar</title><link>https://evilvlso.github.io</link></image><lastBuildDate>Tue, 02 Apr 2024 08:58:51 +0000</lastBuildDate><managingEditor>tango</managingEditor><ttl>60</ttl><webMaster>tango</webMaster><item><title>inotify+rsync同步脚本</title><link>https://evilvlso.github.io/post/inotify%2Brsync-tong-bu-jiao-ben.html</link><description>&gt; rysnc是一个远程同步工具&#13;
&gt; &#13;
&gt;  inotify是一种文件系统事件监控机制，包括添加、删除、移动、修改等各种事件&#13;
&gt; &#13;
&gt;  **inotify+rsync** 可以实现监控某目录是否变动，进而增量备份同步&#13;
&#13;
### Shell&#13;
&lt;!--more--&gt;&#13;
```shell&#13;
current_date=$(date +%Y%m%d_%H%M%S)&#13;
source_path=/tmp/src/&#13;
log_file=/var/log/rsync_client.log&#13;
&#13;
#rsync&#13;
rsync_server=172.29.88.223&#13;
rsync_user=sean&#13;
rsync_pwd=/etc/rsync_client.pwd&#13;
rsync_module=module_test&#13;
INOTIFY_EXCLUDE='(.*/*\.log|.*/*\.swp)$|^/tmp/src/mail/(2014|20.*/.*che.*)'&#13;
RSYNC_EXCLUDE='/etc/rsyncd.d/rsync_exclude.lst'&#13;
&#13;
#rsync client pwd check&#13;
if [ ! -e ${rsync_pwd} ];then&#13;
    echo -e "rsync client passwod file ${rsync_pwd} does not exist!"&#13;
    exit 0&#13;
fi&#13;
&#13;
#inotify_function&#13;
inotify_fun(){&#13;
    /usr/bin/inotifywait -mrq --timefmt '%Y/%m/%d-%H:%M:%S' --format '%T %w %f' \&#13;
          --exclude ${INOTIFY_EXCLUDE}  -e modify,delete,create,move,attrib ${source_path} \&#13;
          | while read file&#13;
      do&#13;
          /usr/bin/rsync -auvrtzopgP --exclude-from=${RSYNC_EXCLUDE} --progress --bwlimit=200 --password-file=${rsync_pwd} ${source_path} ${rsync_user}@${rsync_server}::${rsync_module} &#13;
      done&#13;
}&#13;
&#13;
#inotify log&#13;
inotify_fun &gt;&gt; ${log_file} 2&gt;&amp;1 &amp;&#13;
```&#13;
### 后台启动脚本即可&#13;
&#13;
### 精简版&#13;
```&#13;
#!/bin/sh&#13;
/usr/local/bin/inotifywait -mrq -e modify,attrib,move,create,delete /test | while read file&#13;
do&#13;
    rsync -a --delete /test/ 192.168.1.20:/testbak/&#13;
    echo "$file在`date +'%F %T %A'`同步成功" &gt;&gt; /var/log/rsync.log&#13;
done&#13;
```。</description><guid isPermaLink="true">https://evilvlso.github.io/post/inotify%2Brsync-tong-bu-jiao-ben.html</guid><pubDate>Tue, 02 Apr 2024 08:58:22 +0000</pubDate></item><item><title>Linux下打包QT程序</title><link>https://evilvlso.github.io/post/Linux-xia-da-bao-QT-cheng-xu.html</link><description>1. 还是先Release编译程序&#13;
&#13;
2. 将可执行程序复制到一个新目录 src&#13;
&#13;
3. 新建一个脚本**copylib.sh**，主要用来 copy 相关库的,**第一个参数是可执行文件**&#13;
&#13;
   ```&#13;
   #!/bin/bash&#13;
   &#13;
   LibDir=$PWD"/lib"&#13;
   Target=$1&#13;
   &#13;
   lib_array=($(ldd $Target | grep -o "/.*" | grep -o "/.*/[^[:space:]]*"))&#13;
   &#13;
   $(mkdir $LibDir)&#13;
   &#13;
   for Variable in ${lib_array[@]}&#13;
   do&#13;
       cp "$Variable" $LibDir&#13;
   done&#13;
   ```&#13;
&#13;
4. 先 copy 程序依赖库，`copylib.sh ISTSC`，将 lib 下的库复制出来&#13;
&#13;
5. 再 copy qt 运行依赖库;&#13;
&#13;
   进入qt平台目录下 `/opt/Qt/5.15.2/gcc_64/plugins/platforms`&#13;
&#13;
   运行`copylib.sh libqxcb.so`&#13;
&#13;
   copy lib下的库到src中&#13;
   copy platforms目录下其他库到src&#13;
   &#13;
6. COPY mysql的库 `sqldrivers/libqsql.so`和 `/usr/lib/x86_64-linux-gnu/libmysqlclient.so 到src`&#13;
   &#13;
7. copy qml下的所有到sr c&#13;
&#13;
8. copy gcc_x86下的lib库的内容到src下&#13;
&#13;
9. 可以在目录下在创建一个运行脚本,用来设置程序运行库的路径的&#13;
  ```&#13;
  #!/bin/sh&#13;
  appname=`basename $0 | sed s,\.sh$,,`&#13;
  dirname=`dirname $0`&#13;
  tmp="${dirname#?}"&#13;
  if [ "${dirname%$tmp}" != "/" ]; then&#13;
  dirname=$PWD/$dirname&#13;
  fi&#13;
  LD_LIBRARY_PATH=$dirname&#13;
  export LD_LIBRARY_PATH&#13;
  $dirname/$appname "$@"&#13;
  ```&#13;
&#13;
&#13;
&#13;
&gt;&gt;    [参考链接](https://www.huaweicloud.com/articles/ca0f1e1d3ed52d1fd572b4229026aa59.html)。</description><guid isPermaLink="true">https://evilvlso.github.io/post/Linux-xia-da-bao-QT-cheng-xu.html</guid><pubDate>Tue, 02 Apr 2024 08:57:42 +0000</pubDate></item><item><title>logging库添加Handler</title><link>https://evilvlso.github.io/post/logging-ku-tian-jia-Handler.html</link><description>### logging常用配置&#13;
```Python&#13;
    logger = logging.getLogger('what')&#13;
    logger.setLevel(logging.INFO)&#13;
    #设置日志格式&#13;
    formater=logging.Formatter(fmt='%(name)s %(asctime)s %(filename)s [line:%(lineno)d] %(levelname)s : %(message)s ',datefmt='%Y/%m/%d %H:%M')&#13;
    #文件Handler&#13;
    fh=logging.FileHandler('test.log','a',encoding='utf-8')&#13;
    fh.setLevel(logging.ERROR)&#13;
    fh.setFormatter(formater)&#13;
    #自定义Handler&#13;
    th=CustomHandler()&#13;
    th.setFormatter(formater)&#13;
    th.setLevel(logging.INFO)&#13;
    #终端Handler&#13;
    ch = logging.StreamHandler()&#13;
    ch.setLevel(logging.INFO)&#13;
    ch.setFormatter(formater)&#13;
    #添加Handler&#13;
    logger.addHandler(fh)&#13;
    logger.addHandler(ch)&#13;
    logger.addHandler(th)&#13;
```&#13;
### 自定义Hander&#13;
```Python&#13;
class CHandler(logging.Handler):&#13;
    def __init__(self):&#13;
        logging.Handler.__init__(self)&#13;
        self.client=pymysql.Connection(host='127.0.0.1',user='root',passwd='qweqwe',db='sharesnews',charset='utf8mb4',autocommit=True)&#13;
        self.cursor=self.client.cursor()&#13;
    def emit(self, record):&#13;
        try:&#13;
            sql='insert into exceptions (exception,add_time) VALUES (%s,%s)'&#13;
            msg = sql.format(record)&#13;
            self.cursor.execute(sql,(msg,datetime.now()))&#13;
        except Exception:&#13;
            self.handleError(record)&#13;
            self.client.rollback()&#13;
```。</description><guid isPermaLink="true">https://evilvlso.github.io/post/logging-ku-tian-jia-Handler.html</guid><pubDate>Tue, 02 Apr 2024 08:56:51 +0000</pubDate></item><item><title>itertools库实现排列 组合 笛卡尔积</title><link>https://evilvlso.github.io/post/itertools-ku-shi-xian-pai-lie-%20-zu-he-%20-di-qia-er-ji.html</link><description># 排列 (itertools.permutations)&#13;
&#13;
从迭代序列里选取n个数字进行排列，有顺序&#13;
&#13;
```python&#13;
a=[1,3,4]&#13;
list(itertools.permutations(a,2))&#13;
[(4, 1), (4, 3), (1, 4), (1, 3), (3, 4), (3, 1)]&#13;
&#13;
list(itertools.permutations(a,3))&#13;
Out[36]: [(4, 1, 3), (4, 3, 1), (1, 4, 3), (1, 3, 4), (3, 4, 1), (3, 1, 4)]&#13;
```&#13;
&#13;
## 组合(itertools.combinations)&#13;
&#13;
从迭代序列里选取n个数字进行组合，重在组合&#13;
&#13;
```python&#13;
a=[1,3,4]&#13;
list(itertools.combinations(a,2))&#13;
Out[32]: [(4, 1), (4, 3), (1, 3)]&#13;
&#13;
list(itertools.combinations_with_replacement(a,2))&#13;
Out[33]: [(4, 4), (4, 1), (4, 3), (1, 1), (1, 3), (3, 3)]  #可重复利用数字&#13;
```&#13;
&#13;
## 笛卡尔积(itertools.product)&#13;
&#13;
对多个迭代器进行笛卡尔积组合，参数的意思是从每个迭代器中选取几个值进行组合&#13;
&#13;
```&#13;
a=[1,3,4]&#13;
list(itertools.product([1,2,3],[2,3,4],repeat=2))&#13;
```&#13;
。</description><guid isPermaLink="true">https://evilvlso.github.io/post/itertools-ku-shi-xian-pai-lie-%20-zu-he-%20-di-qia-er-ji.html</guid><pubDate>Tue, 02 Apr 2024 08:56:10 +0000</pubDate></item><item><title>mitmproxy脚本常用接口</title><link>https://evilvlso.github.io/post/mitmproxy-jiao-ben-chang-yong-jie-kou.html</link><description>```&#13;
http.HTTPFlow 实例 flow&#13;
flow.request.headers #获取所有头信息，包含Host、User-Agent、Content-type等字段&#13;
flow.request.url #完整的请求地址，包含域名及请求参数，但是不包含放在body里面的请求参数&#13;
flow.request.pretty_url #同flow.request.url目前没看出什么差别&#13;
flow.request.host #域名&#13;
flow.request.method #请求方式。</description><guid isPermaLink="true">https://evilvlso.github.io/post/mitmproxy-jiao-ben-chang-yong-jie-kou.html</guid><pubDate>Tue, 02 Apr 2024 08:54:54 +0000</pubDate></item><item><title>Mysql主从配置及可能问题</title><link>https://evilvlso.github.io/post/Mysql-zhu-cong-pei-zhi-ji-ke-neng-wen-ti.html</link><description>---&#13;
### 从账号&#13;
```&#13;
grant replication slave on *.* to slave@192.168.1.8 identified by '123456';&#13;
```&#13;
### my.cnf&#13;
&lt;!--more--&gt;&#13;
```&#13;
[mysqld]&#13;
port = 3306&#13;
datadir = /data&#13;
log_bin = /data/master-log-bin&#13;
log_bin_index = /data/master-log-bin.index&#13;
socket = /tmp/mysql.sock&#13;
expire_logs_days = 3&#13;
&lt;!--more--&gt;&#13;
open_files_limit = 10000&#13;
binlog_format =mixed &#13;
# 很重要&#13;
server_id = 2&#13;
log_error = /data/log/master-error.log&#13;
&#13;
lower_case_table_names=1&#13;
slave_type_conversions=ALL_NON_LOSSY&#13;
#从&#13;
slave-skip-errors =1756  &#13;
auto_increment_offset = 2&#13;
auto_increment_increment = 2&#13;
max_connections = 500&#13;
character-set-server = utf8mb4&#13;
wait_timeout = 120&#13;
#GTID配置&#13;
gtid_mode = on&#13;
#必须&#13;
enforce-gtid-consistency = true&#13;
binlog-do-db = shares3&#13;
&#13;
log_slave_updates = on&#13;
&#13;
slave-parallel-workers=0&#13;
master-info-repository = table&#13;
relay-log-info-repository = table&#13;
&#13;
[mysql]&#13;
socket = /tmp/mysql.sock&#13;
```&#13;
&#13;
*  数据冲突之列的复制错误，至于跳过事物Id本身，就不复杂了。</description><guid isPermaLink="true">https://evilvlso.github.io/post/Mysql-zhu-cong-pei-zhi-ji-ke-neng-wen-ti.html</guid><pubDate>Tue, 02 Apr 2024 08:53:58 +0000</pubDate></item><item><title>one-hot编码的三种实现方法</title><link>https://evilvlso.github.io/post/one-hot-bian-ma-de-san-zhong-shi-xian-fang-fa.html</link><description>## label转one_hot编码的方法&#13;
&#13;
1. 常见的是用numpy的方法，代码如下：&#13;
&#13;
   ```python&#13;
    y= cv2.imread(maskPath,cv2.IMREAD_GRAYSCALE)&#13;
    y= cv2.resize(y,(self.image_size,self.image_size))&#13;
    y[y&lt;=100]=0  #背景类&#13;
    y[y&gt;100]=1   #病灶类&#13;
    y_onehot=np.eye(self.num_classes)[y.reshape([-1])]&#13;
    # 到第五行其实已经成为one_hot编码了,格式为  [[1,0],[1,0],[1,0],[1,0],[1,0],...[0,1],]&#13;
    y_onehot=y_onehot.reshape(self.num_classes,self.image_size,self.image_size)&#13;
    # 这一步是为reshape，但是这种reshape方式的结果呈现并不是直觉理解的（不是通道值互斥的），原因是因为reshape的原理&#13;
    # 正确的应该是&#13;
    y_onehot = rearrange(y_onehot,"(h w) c-&gt;c h w",h=self.image_size)&#13;
   ```&#13;
&#13;
2. pytorch也有one_hot编码方法，代码如下：&#13;
&#13;
   ```python&#13;
   from torch.nn.functional as F&#13;
   y= cv2.imread(self.Y[index],cv2.IMREAD_GRAYSCALE)&#13;
   y= cv2.resize(y,(self.image_size,self.image_size))&#13;
   y[y&lt;=100]=0  #背景类&#13;
   y[y&gt;100]=1   #病灶类&#13;
   # y就是图片的label&#13;
   &#13;
   y_onehot=F.one_hot(torch.Tensor(y.reshpe(-1).to(torch.int64)),num_classes)&#13;
   # 这一步结果是one_hot形式了，下一步需要变换shape就行&#13;
   # 注意第一个参数是Tensor类型并且要转为torch.int64&#13;
   y_onehot = rearrange(y_onehot,"(h w) c-&gt;c h w",h=self.image_size)&#13;
   ```&#13;
&#13;
3. keras也有one_host编码方法，随后补充&#13;
&#13;
   ```python&#13;
   from keras.utils import to_categorical&#13;
   intput=np.array([1,2,3,4])&#13;
   y_onehot=to_categorical(input)&#13;
   ```。</description><guid isPermaLink="true">https://evilvlso.github.io/post/one-hot-bian-ma-de-san-zhong-shi-xian-fang-fa.html</guid><pubDate>Tue, 02 Apr 2024 08:52:13 +0000</pubDate></item><item><title>生产者消费者模式采集谷歌学术示例</title><link>https://evilvlso.github.io/post/sheng-chan-zhe-xiao-fei-zhe-mo-shi-cai-ji-gu-ge-xue-shu-shi-li.html</link><description>工作示意图如下：&#13;
&#13;
![text-here](https://i.loli.net/2020/05/18/qGjnJFP9pu8KQoM.png)&#13;
&#13;
&#13;
凑合看&#13;
&#13;
&lt;!--more--&gt;&#13;
&#13;
```Python&#13;
&#13;
import re&#13;
import redis&#13;
import requests&#13;
import retrying&#13;
from threading import Thread&#13;
from openpyxl.workbook import Workbook&#13;
from urllib.request import urljoin&#13;
from scrapy.selector import Selector&#13;
from concurrent.futures import ThreadPoolExecutor, as_completed&#13;
from queue import Queue,Empty&#13;
&#13;
r = redis.Redis("127.0.0.1", db=0)&#13;
q = Queue(maxsize=100)&#13;
&#13;
proxies = {&#13;
    "http": "http://127.0.0.1:1087",&#13;
    "https": "http://127.0.0.1:1087"&#13;
}&#13;
headers = {&#13;
    'authority': 'scholar.google.com',&#13;
    'cache-control': 'no-cache',&#13;
    'upgrade-insecure-requests': '1',&#13;
    'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.122 Safari/537.36',&#13;
    'accept': 'image/webp,image/apng,image/*,*/*;q=0.8',&#13;
    'x-client-data': 'CJS2yQEIo7bJAQjBtskBCKmdygEI0K/KAQi8sMoBCO21ygEIjrrKAQjmxsoB',&#13;
    'sec-fetch-site': 'same-origin',&#13;
    'sec-fetch-mode': 'no-cors',&#13;
    'sec-fetch-user': '?1',&#13;
    'sec-fetch-dest': 'empty',&#13;
    'referer': 'https://scholar.google.com/scholar?start=20&amp;hl=en&amp;as_sdt=2005&amp;sciodt=0,5&amp;cites=9023096709689140743&amp;scipsc=',&#13;
    'accept-language': 'zh-CN,zh;q=0.9',&#13;
    'Referer': 'https://scholar.google.com/scholar?start=20&amp;hl=en&amp;as_sdt=2005&amp;sciodt=0,5&amp;cites=9023096709689140743&amp;scipsc=',&#13;
    'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.122 Safari/537.36',&#13;
    'pragma': 'no-cache',&#13;
    'cookie': r.get("cookies").decode("ASCII"),&#13;
}&#13;
&#13;
&#13;
def try_if_ssl_error(exception):&#13;
    if isinstance(exception, (&#13;
            requests.exceptions.SSLError, requests.exceptions.ProxyError, requests.exceptions.ReadTimeout,&#13;
            requests.exceptions.ConnectionError)):&#13;
        print(f"代理可能失效 {exception}")&#13;
        return True&#13;
    print(f"意料之外错误 {exception}")&#13;
    return False&#13;
&#13;
&#13;
def try_if_robot(result):&#13;
    if "you're not a robot" in result.text or "人机身份验证" in result.text:&#13;
        print("出现 Robot 检测")&#13;
        headers["cookie"] = r.get("cookies").decode("ASCII")&#13;
        return True&#13;
    if "detected unusual traffic" in result.text or "异常流量" in result.text:&#13;
        print("出现 流量 检测")&#13;
        headers["cookie"] = r.get("cookies").decode("ASCII")&#13;
        return True&#13;
    if "sending automated queries" in result.text:&#13;
        headers["cookie"] = r.get("cookies").decode("ASCII")&#13;
        print(" your computer or network may be sending automated queries")&#13;
        return True&#13;
    if "/recaptcha/api.js" in result.text:&#13;
        headers["cookie"] = r.get("cookies").decode("ASCII")&#13;
        print("出现 验证码 检测 ")&#13;
        return True&#13;
    return False&#13;
&#13;
&#13;
@retrying.retry(stop_max_attempt_number=500, retry_on_result=try_if_robot, retry_on_exception=try_if_ssl_error,&#13;
                wait_fixed=10000)&#13;
def fetch(**kwargs):&#13;
    """&#13;
    :param kwargs:  start cites&#13;
    :return:&#13;
    """&#13;
    url = kwargs.get("url")&#13;
    response = requests.get(url, headers=headers, proxies=proxies, timeout=7)&#13;
    return response&#13;
&#13;
&#13;
class Proceser():&#13;
&#13;
    def __init__(self, *args, **kwargs):&#13;
        filename = kwargs.get("filename")&#13;
        with open(filename, "r") as f:&#13;
            self.data = f.readlines()&#13;
        self.t = ThreadPoolExecutor(max_workers=2)&#13;
        pass&#13;
&#13;
    def _proc(self, kw):&#13;
        """&#13;
&#13;
        :param kw:&#13;
        :return:&#13;
        """&#13;
        kw = '+'.join(kw.split(" "))&#13;
        url = f"/scholar?q={kw}"&#13;
        base_url = "https://scholar.google.com/scholar"&#13;
        url = urljoin(base_url, url)&#13;
        url = url.replace("zh-CN", "en")&#13;
        res = fetch(url=url)&#13;
        return {"res": res, "kw": kw}&#13;
&#13;
    def callback(self, result):&#13;
        result = result.result()&#13;
        res = result.get("res")&#13;
        kw = result.get("kw")&#13;
        seed_infos = self.extract(res, seed=True)&#13;
        for seed_info in seed_infos:&#13;
            seed_cites = seed_info.get("cites", 0)&#13;
            try:&#13;
                seed_cites = int(seed_cites)&#13;
            except ValueError as e:&#13;
                print(f"Cites ERROR:{res.url}")&#13;
            else:&#13;
                for start in range(0, seed_cites, 20):&#13;
                    cite_url = "https://scholar.google.com"+seed_info["cites_url"] + f"&amp;num=20&amp;start={start}"&#13;
                    q.put({&#13;
                        "kw": kw,&#13;
                        "seed_title": seed_info["title"],&#13;
                        "seed_cites": seed_info["cites"],&#13;
                        "cite_url": cite_url,&#13;
                    })&#13;
&#13;
    def run(self):&#13;
        tasks = [self.t.submit(self._proc, kw) for kw in self.data]&#13;
        for task in as_completed(tasks):&#13;
            self.callback(task)&#13;
&#13;
    @staticmethod&#13;
    def extract(response, seed=False):&#13;
        def _proc_cites(cites):&#13;
            return ''.join(re.findall(r'(\d{0,5})', cites))&#13;
&#13;
        def _proc_info(info):&#13;
            publish = ''.join(re.findall(r'-(.*?)-', info)).replace("…", "").replace("\xa0", "")&#13;
            author = ''.join(re.findall(r'(.*?)-', info)).replace("…", "").replace("\xa0", "")&#13;
            return publish, author&#13;
&#13;
        if not "did not match any articles" in response.text:&#13;
            html = Selector(response)&#13;
            if seed:&#13;
                documents = [html.xpath("//div[@id='gs_res_ccl_mid']/div")[0]]&#13;
            else:&#13;
                documents = html.xpath("//div[@id='gs_res_ccl_mid']/div")&#13;
            infos = []&#13;
            for document in documents:&#13;
                title = document.xpath(&#13;
                    "string(.//div[contains(@class,'gs_ri')]/h3/a|.//div[contains(@class,'gs_ri')]/h3/span[2])").extract_first(&#13;
                    default="")&#13;
                url = document.xpath(".//div[contains(@class,'gs_ri')]/h3/a/@href").extract_first(default="")&#13;
                info = document.xpath("string(.//div[contains(@class,'gs_ri')]/div[@class='gs_a'])").extract_first(&#13;
                    default="")&#13;
                cites_url = document.xpath(".//div[contains(@class,'gs_fl')]/a[3]/@href").extract_first(default="")&#13;
                cites = document.xpath(".//div[contains(@class,'gs_fl')]/a[3]/text()").extract_first(default="")&#13;
                cites = _proc_cites(cites)&#13;
                publish, author = _proc_info(info)&#13;
                infos.append(&#13;
                    {"title": title, "publish": publish, "author": author, "cites_url": cites_url, "cites": cites,&#13;
                     "url": url})&#13;
            return infos&#13;
&#13;
&#13;
class Customer():&#13;
    def __init__(self,savefilename):&#13;
        self.savefilename=savefilename&#13;
        self.t = ThreadPoolExecutor(max_workers=100)&#13;
        self.workbook = Workbook()&#13;
        self.sheet = self.workbook["Sheet"]&#13;
        self.sheet.append(("关键词文件名", "第一匹配结果文献", "本文被引用数", "引用此文文献名", "引用此文作者", "引用此文期刊名", "引用此文文献引用数", "url"))&#13;
&#13;
    @staticmethod&#13;
    def extract(response, seed=False):&#13;
        def _proc_cites(cites):&#13;
            return ''.join(re.findall(r'(\d{0,5})', cites))&#13;
&#13;
        def _proc_info(info):&#13;
            publish = ''.join(re.findall(r'-(.*?)-', info)).replace("…", "").replace("\xa0", "")&#13;
            author = ''.join(re.findall(r'(.*?)-', info)).replace("…", "").replace("\xa0", "")&#13;
            return publish, author&#13;
&#13;
        if not "did not match any articles" in response.text:&#13;
            html = Selector(response)&#13;
            if seed:&#13;
                documents = [html.xpath("//div[@id='gs_res_ccl_mid']/div")[0]]&#13;
            else:&#13;
                documents = html.xpath("//div[@id='gs_res_ccl_mid']/div")&#13;
            infos = []&#13;
            for document in documents:&#13;
                title = document.xpath(&#13;
                    "string(.//div[contains(@class,'gs_ri')]/h3/a|.//div[contains(@class,'gs_ri')]/h3/span[2])").extract_first(&#13;
                    default="")&#13;
                url = document.xpath(".//div[contains(@class,'gs_ri')]/h3/a/@href").extract_first(default="")&#13;
                info = document.xpath("string(.//div[contains(@class,'gs_ri')]/div[@class='gs_a'])").extract_first(&#13;
                    default="")&#13;
                cites_url = document.xpath(".//div[contains(@class,'gs_fl')]/a[3]/@href").extract_first(default="")&#13;
                cites = document.xpath(".//div[contains(@class,'gs_fl')]/a[3]/text()").extract_first(default="")&#13;
                cites = _proc_cites(cites)&#13;
                publish, author = _proc_info(info)&#13;
                infos.append(&#13;
                    {"title": title, "publish": publish, "author": author, "cites_url": cites_url, "cites": cites,&#13;
                     "url": url})&#13;
            return infos&#13;
&#13;
    def get_infos(self):&#13;
        print(f"Queue size is {q.qsize()}")&#13;
        try:&#13;
            infos = q.get(block=True,timeout=180)&#13;
            return infos&#13;
        except Empty:&#13;
            print(f"Queue size is {q.qsize()}")&#13;
            print("队列0000000结束了！")&#13;
            self.workbook.save(self.savefilename)&#13;
&#13;
    def run(self):&#13;
        infos = self.get_infos()&#13;
        while infos:&#13;
            self.t.submit(self._fe, infos=infos).add_done_callback(self.callback)&#13;
            infos = self.get_infos()&#13;
&#13;
    def _fe(self, infos):&#13;
        url = infos.get("cite_url")&#13;
        res = fetch(url=url)&#13;
        cite_infos = self.extract(res)&#13;
        for cite_info in cite_infos:&#13;
            cite_info.update(infos)&#13;
        return cite_infos&#13;
&#13;
    def callback(self, result):&#13;
        cite_infos = result.result()&#13;
        print(f"添加文献{len(cite_infos)}")&#13;
        for infos in cite_infos:&#13;
            self.sheet.append((&#13;
                infos.get("kw"), infos.get("seed_title"), infos.get("seed_cites"), infos.get("title"), infos.get("author"), infos.get("publish"), infos.get("cites"),infos.get("url")&#13;
            ))&#13;
&#13;
if __name__ == '__main__':&#13;
    pr=Proceser(filename="again.txt")&#13;
    cu=Customer(savefilename="test.xlsx")&#13;
    t1=Thread(target=pr.run)&#13;
    t2=Thread(target=cu.run)&#13;
    t1.start()&#13;
    t2.start()&#13;
    t1.join()&#13;
    t2.join()&#13;
```。</description><guid isPermaLink="true">https://evilvlso.github.io/post/sheng-chan-zhe-xiao-fei-zhe-mo-shi-cai-ji-gu-ge-xue-shu-shi-li.html</guid><pubDate>Tue, 02 Apr 2024 08:51:22 +0000</pubDate></item><item><title>Python操作excel-openpyxl</title><link>https://evilvlso.github.io/post/Python-cao-zuo-excel-openpyxl.html</link><description>&gt; openpyxl是一个很好用的操作excel的库&#13;
&gt; &#13;
&gt; 常用的操作：&#13;
&gt; &#13;
&gt;  * 添加表头 **add_sheet**&#13;
&gt;  * 添加数据(元组) **add_data**&#13;
&gt;  * 设置表头格式(仅字体)  **set_header_font**&#13;
&gt;  * 删除 **sheet delete_sheet**&#13;
&gt;  * 保存excel **save**&#13;
&gt; &#13;
&gt; 还有很多友好的操作&#13;
&#13;
```Python&#13;
class Xlsx():&#13;
    def __init__(self):&#13;
        self.workbook = Workbook()&#13;
        self.index=1&#13;
        pass&#13;
&#13;
    def add_sheet(self,sheetname="Sheet"):&#13;
        return self.workbook.create_sheet(sheetname,self.index+1)&#13;
&#13;
    def add_data(self,data,sheet="Sheet"):&#13;
        '''&#13;
        :param sheet :sheet对象&#13;
        :param data: data最好是一个元组&#13;
        :return:&#13;
        '''&#13;
        if isinstance(data,tuple):&#13;
            sheet.append(data)&#13;
        else:&#13;
            sheet.append(tuple(data))&#13;
&#13;
    def set_header_font(self,sheetname="Sheet"):&#13;
        '''&#13;
        格式化行头&#13;
        :param sheetname:&#13;
        :return:&#13;
        '''&#13;
        font = Font(u'宋体', size=13, bold=True, color='000000')&#13;
        for i in sheetname["1"]:&#13;
            i.font = font&#13;
            &#13;
    def delete_sheet(self,sheetname="Sheet"):&#13;
        '''&#13;
        删除sheet&#13;
        :param sheetname:&#13;
        :return:&#13;
        '''&#13;
        self.workbook.remove(self.workbook[sheetname])&#13;
&#13;
    def save(self,filename):&#13;
        self.workbook.save(filename)&#13;
```。</description><guid isPermaLink="true">https://evilvlso.github.io/post/Python-cao-zuo-excel-openpyxl.html</guid><pubDate>Tue, 02 Apr 2024 08:50:09 +0000</pubDate></item><item><title>QtNetwork和QtTableview的使用</title><link>https://evilvlso.github.io/post/QtNetwork-he-QtTableview-de-shi-yong.html</link><description>## Qt Network&#13;
&#13;
1. 同步请求数据&#13;
&#13;
   ```c++&#13;
   QNetworkAccessManager *mgr = new QNetworkAccessManager(this);&#13;
   const QUrl url(QStringLiteral("http://myserver.com/api"));&#13;
   QNetworkRequest request(url);&#13;
   request.setHeader(QNetworkRequest::ContentTypeHeader, "application/json");&#13;
   &#13;
   QJsonObject obj;&#13;
   obj["key1"] = "value1";&#13;
   obj["key2"] = "value2";&#13;
   QJsonDocument doc(obj);&#13;
   QByteArray data = doc.toJson();&#13;
   // or&#13;
   // QByteArray data("{\"key1\":\"value1\",\"key2\":\"value2\"}");&#13;
   QNetworkReply *reply = mgr-&gt;post(request, data);&#13;
   &#13;
   QObject::connect(reply, &amp;QNetworkReply::finished, [=](){&#13;
       if(reply-&gt;error() == QNetworkReply::NoError){&#13;
           QString contents = QString::fromUtf8(reply-&gt;readAll());&#13;
           qDebug() &lt;&lt; contents;&#13;
       }&#13;
       else{&#13;
           QString err = reply-&gt;errorString();&#13;
           qDebug() &lt;&lt; err;&#13;
       }&#13;
       reply-&gt;deleteLater();&#13;
   });&#13;
   ```&#13;
&#13;
* TableView 初始化&#13;
&#13;
```c++&#13;
void myc::setTableHead()&#13;
{&#13;
    if(ui-&gt;tableView-&gt;model()==nullptr){&#13;
      QStandardItemModel *  theModel = new QStandardItemModel(ui-&gt;tableView);&#13;
      ui-&gt;tableView-&gt;setModel(theModel);&#13;
   		 }&#13;
    QStandardItemModel * theModel = (QStandardItemModel*) ui-&gt;tableView-&gt;model();&#13;
	 theSelection = new QItemSelectionModel(theModel);//选中模型类 从ui中获取 而不是设置类成员&#13;
	 ui-&gt;tableView-&gt;setSelectionModel(theSelection);&#13;
    QStringList headerList;&#13;
    headerList&lt;&lt;"序号"&lt;&lt;"报告编号"&lt;&lt;"姓名"&lt;&lt;"性别"&lt;&lt;"创建时间";&#13;
    theModel-&gt;setHorizontalHeaderLabels(headerList);&#13;
    theModel-&gt;setRowCount(5);  //设置表格行数 &#13;
    ui-&gt;tableView-&gt;setGridStyle(Qt::SolidLine);&#13;
    ui-&gt;tableView-&gt;horizontalHeader()-&gt;setStretchLastSection(true);&#13;
    ui-&gt;tableView-&gt;horizontalHeader()-&gt;setSectionResizeMode(QHeaderView::ResizeToContents);&#13;
    ui-&gt;tableView-&gt;verticalHeader()-&gt;setVisible(true);   // 是否隐藏列表头&#13;
    ui-&gt;tableView-&gt;setEditTriggers(QAbstractItemView::NoEditTriggers); //是否可编辑 cell&#13;
    ui-&gt;tableView-&gt;setContextMenuPolicy(Qt::CustomContextMenu);    //弹出右键菜单策略&#13;
    ui-&gt;tableView-&gt;setSelectionBehavior(QAbstractItemView::SelectRows); //一选就选择整行&#13;
    ui-&gt;tableView-&gt;setSelectionMode(QAbstractItemView::SingleSelection); //只选择一行/多行&#13;
}&#13;
```&#13;
&#13;
* 添加一行数据&#13;
&#13;
  ```c++&#13;
  void myc::querybtn_clicked()&#13;
  {&#13;
      &#13;
      QStandardItemModel * theModel = (QStandardItemModel*)ui-&gt;tableView-&gt;model();&#13;
      int start= theModel-&gt;rowCount();  // 有start也就是从表格现有的行数下一个开始&#13;
      QString sql =  QString("select * from patients");&#13;
      QList&lt;QList&lt;QVariant&gt;&gt; query_list = con-&gt;dbquery(sql);&#13;
      for(int i=0;i&lt;query_list.length();i++){&#13;
          QList&lt;QStandardItem*&gt; ItemList;&#13;
          ItemList&lt;&lt;(new QStandardItem(query_list[i][0].toString()));&#13;
          ItemList&lt;&lt;(new QStandardItem(query_list[i][1].toString()));&#13;
          ItemList&lt;&lt;(new QStandardItem(query_list[i][2].toString()));&#13;
          ItemList&lt;&lt;(new QStandardItem(query_list[i][3].toString()=="0"?"女":"男"));&#13;
          ItemList&lt;&lt;(new QStandardItem(query_list[i][4].toString()));&#13;
          theModel-&gt;insertRow(i+start,ItemList);  // 插入&#13;
      }&#13;
  &#13;
  ```。</description><guid isPermaLink="true">https://evilvlso.github.io/post/QtNetwork-he-QtTableview-de-shi-yong.html</guid><pubDate>Tue, 02 Apr 2024 08:49:31 +0000</pubDate></item><item><title>redis面试问题</title><link>https://evilvlso.github.io/post/redis-mian-shi-wen-ti.html</link><description># 快的原因&#13;
&#13;
1. 基于内存实现的&#13;
2. 采用io多路复用模型。</description><guid isPermaLink="true">https://evilvlso.github.io/post/redis-mian-shi-wen-ti.html</guid><pubDate>Tue, 02 Apr 2024 08:45:56 +0000</pubDate></item><item><title>scrapy启动多spider</title><link>https://evilvlso.github.io/post/scrapy-qi-dong-duo-spider.html</link><description>### 好使&#13;
```Python&#13;
import scrapy&#13;
from scrapy.crawler import CrawlerProcess&#13;
from scrapy.utils.project import get_project_settings&#13;
process = CrawlerProcess(get_project_settings())&#13;
# 指定多个spider&#13;
process.crawl("fen")&#13;
process.crawl("fuck")&#13;
# 执行所有 spider&#13;
# for spider_name in process.spider_loader.list():&#13;
#     print(spider_name)&#13;
    # process.crawl(spider_name)&#13;
process.start()&#13;
&#13;
```。</description><guid isPermaLink="true">https://evilvlso.github.io/post/scrapy-qi-dong-duo-spider.html</guid><pubDate>Tue, 02 Apr 2024 08:43:47 +0000</pubDate></item><item><title>雪花算法</title><link>https://evilvlso.github.io/post/xue-hua-suan-fa.html</link><description>&gt; `7uQJnf1B3NnRjV` 像这种掺杂数字字母的字符串就是雪花算法生成的。</description><guid isPermaLink="true">https://evilvlso.github.io/post/xue-hua-suan-fa.html</guid><pubDate>Tue, 02 Apr 2024 08:43:11 +0000</pubDate></item><item><title>matplotlib画子图代码示例</title><link>https://evilvlso.github.io/post/matplotlib-hua-zi-tu-dai-ma-shi-li.html</link><description>## subplot画子图&#13;
```python&#13;
for index,n in enumerate(imgName):&#13;
    plt.subplot(params["batch_size"],params["batch_size"],index*3+1,title="Input" if index==0 else "")&#13;
    plt.imshow(x[index].transpose(0,1).transpose(1,2).contiguous())&#13;
    plt.axis("off") # 去掉 x y轴&#13;
    plt.subplot(params["batch_size"],params["batch_size"],index*3+2,title="GT)&#13;
    plt.imshow(y[index],cmap="gray")&#13;
    plt.axis("off")&#13;
    plt.subplot(params["batch_size"],params["batch_size"],index*3+3,title="Mask")&#13;
    plt.imshow(mask[index],cmap="gray")&#13;
    plt.axis("off")&#13;
    # plt.subplots_adjust(left=0.027,&#13;
    #                     bottom=0,&#13;
    #                     right=0.99,&#13;
    #                     top=0.93,&#13;
    #                     wspace=0.005,&#13;
    #                     hspace=0.045)&#13;
    fig.tight_layout()&#13;
```&#13;
&#13;
## subplots画子图&#13;
&#13;
```python&#13;
fig,axes=plt.subplots(params["batch_size"],params["batch_size"])&#13;
for index,n in enumerate(imgName):&#13;
    axes[index,0].imshow(x[index].transpose(0,1).transpose(1,2).contiguous())&#13;
    axes[index, 0].axis("off")&#13;
    axes[index,1].imshow(y[index],cmap="gray")&#13;
    axes[index, 1].axis("off")&#13;
    axes[index,2].imshow(mask[index],cmap="gray")&#13;
    axes[index, 2].axis("off")&#13;
    axes[0,0].set_title("Input")&#13;
    axes[0,1].set_title("GT")&#13;
    axes[0,2].set_title("Mask")&#13;
    plt.subplots_adjust(left=0.027,&#13;
                            bottom=0,&#13;
                            right=0.99,&#13;
                            top=0.93,&#13;
                            wspace=0.005,&#13;
                            hspace=0.045)&#13;
```&#13;
。</description><guid isPermaLink="true">https://evilvlso.github.io/post/matplotlib-hua-zi-tu-dai-ma-shi-li.html</guid><pubDate>Tue, 02 Apr 2024 08:42:22 +0000</pubDate></item><item><title>Ubuntu安装chrome脚本</title><link>https://evilvlso.github.io/post/Ubuntu-an-zhuang-chrome-jiao-ben.html</link><description>---&#13;
```Shell&#13;
#!/bin/bash&#13;
apt-get update&#13;
apt-get install -y libxss1 libappindicator1 libindicator7&#13;
wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb&#13;
dpkg -i  google-chrome-stable_current_amd64.deb&#13;
```&#13;
### 如果报错了&#13;
`apt-get install -y -f ` 就OK👌了。</description><guid isPermaLink="true">https://evilvlso.github.io/post/Ubuntu-an-zhuang-chrome-jiao-ben.html</guid><pubDate>Tue, 02 Apr 2024 08:37:41 +0000</pubDate></item><item><title>uwsgi配置以及使用</title><link>https://evilvlso.github.io/post/uwsgi-pei-zhi-yi-ji-shi-yong.html</link><description>### 使用&#13;
```&#13;
uwsgi --ini uwsgi.ini             # 启动&#13;
uwsgi --reload uwsgi.pid          # 重启&#13;
uwsgi --stop uwsgi.pid            # 关闭&#13;
```&#13;
&lt;!--more--&gt;&#13;
### 配置&#13;
```&#13;
[uwsgi]&#13;
chdir=/opt/   &#13;
&#13;
callable=app  #flask专用&#13;
home=/root/env/&#13;
wsgi-file=xdbg/wsgi.py&#13;
master=true&#13;
py-autoreload=1                              # py文件修改，自动加载&#13;
processes=4&#13;
threads=2&#13;
&#13;
pidfile=%(chdir)/uwsgi.pid&#13;
socket=/socket/uwsgi.sock&#13;
chmod-socket = 664&#13;
vacuum=true    #退出uwsgi是否清理中间文件，包含pid、sock和status文件&#13;
daemonize=%(chdir)/cloudmonitor.log  #配合supervisor去掉并且改到stdout_logfile docker中要去掉&#13;
static-map = /static=/opt/static&#13;
```&#13;
&#13;
&gt; 参考 https://www.jianshu.com/p/c3b13b5ad3d7。</description><guid isPermaLink="true">https://evilvlso.github.io/post/uwsgi-pei-zhi-yi-ji-shi-yong.html</guid><pubDate>Tue, 02 Apr 2024 08:35:33 +0000</pubDate></item><item><title>vimrc备份</title><link>https://evilvlso.github.io/post/vimrc-bei-fen.html</link><description>&gt; 万古长青的编辑器 **vim**&#13;
&gt; &#13;
&gt; 而且X格满满&#13;
&#13;
### vimrc&#13;
```&#13;
set nocompatible  &#13;
set hlsearch&#13;
set number  &#13;
set history=1000&#13;
set background=dark &#13;
syntax on  &#13;
set autoindent &#13;
set tabstop=4&#13;
set expandtab&#13;
set shiftwidth=4&#13;
&#13;
let mapleader=","&#13;
&#13;
" colors&#13;
set background=dark&#13;
colorscheme hybrid&#13;
&#13;
" jklh&#13;
map &lt;C-j&gt; &lt;C-W&gt;j&#13;
map &lt;C-k&gt; &lt;C-W&gt;k&#13;
map &lt;C-h&gt; &lt;C-W&gt;h&#13;
map &lt;C-l&gt; &lt;C-W&gt;l&#13;
&#13;
" vim-plug&#13;
call plug#begin('~/.vim/plugged')&#13;
Plug 'scrooloose/nerdtree', { 'on':  'NERDTreeToggle' }&#13;
Plug 'yggdroot/indentline'&#13;
Plug 'python-mode/python-mode', { 'for': 'python', 'branch': 'develop' }&#13;
Plug 'majutsushi/tagbar'&#13;
Plug 'tpope/vim-commentary'&#13;
&#13;
call plug#end()&#13;
" NERDTree&#13;
let NERDTreeWinSize=25&#13;
map &lt;F9&gt; :NERDTreeToggle&lt;CR&gt;&#13;
&#13;
" indentline&#13;
let g:indentline_char = '¦'&#13;
&#13;
&#13;
" Tagbar&#13;
nmap &lt;F8&gt; :TagbarToggle&lt;CR&gt;&#13;
let g:tagbar_ctags_bin = "/usr/local/bin/ctags"&#13;
let g:tagbar_width=28&#13;
&#13;
&#13;
" python-mode&#13;
let g:pymode_rope = 1&#13;
let g:pymode_rope_completion = 1&#13;
let g:pymode_rope_complete_on_dot = 1&#13;
set completeopt=menuone,noinsert&#13;
&#13;
" let g:pymode_rope_completion_bind = ''&#13;
" Documentation&#13;
let g:pymode_doc = 0&#13;
let g:pymode_doc_key = 'K'&#13;
"Linting&#13;
let g:pymode_lint = 1&#13;
let g:pymode_lint_checker = "pyflakes,pep8"&#13;
" let g:pymode_lint_on_write = 1&#13;
" Support virtualenv&#13;
let g:pymode_virtualenv = 1&#13;
" Enable breakpoints plugin&#13;
let g:pymode_breakpoint = 1&#13;
let g:pymode_breakpoint_bind = '&lt;leader&gt;b'&#13;
" syntax highlighting&#13;
let g:pymode_syntax = 1&#13;
let g:pymode_syntax_all = 1&#13;
let g:pymode_syntax_indent_errors = g:pymode_syntax_all&#13;
let g:pymode_syntax_space_errors = g:pymode_syntax_all&#13;
" Don't autofold code&#13;
let g:pymode_folding = 0&#13;
let g:pymode_run = 1&#13;
let g:pymode_run_bind = '&lt;leader&gt;r'&#13;
" find definition&#13;
let g:pymode_rope_goto_definition_bind = '&lt;C-c&gt;g'&#13;
let g:pymode_rope_goto_definition_cmd = 'new'&#13;
&#13;
```。</description><guid isPermaLink="true">https://evilvlso.github.io/post/vimrc-bei-fen.html</guid><pubDate>Tue, 02 Apr 2024 08:33:51 +0000</pubDate></item><item><title>vscode中python环境配置文件</title><link>https://evilvlso.github.io/post/vscode-zhong-python-huan-jing-pei-zhi-wen-jian.html</link><description>有两个配置文件 :&#13;
settings.json - 用来运行的配置&#13;
launch.json  -  用来调试的配置&#13;
&gt; 划取代码运行使用的是 settings.json 配置  &#13;
&gt; vscode 下面的解释器选择可以直接更改两个文件的 python 解释器路径&#13;
&#13;
配置展示:  &#13;
settings.json  &#13;
&#13;
```JSON&#13;
{&#13;
    "launch": {&#13;
&#13;
        "configurations": [&#13;
            {"name":"Launch",&#13;
            "type":"python",&#13;
            "request":"launch",&#13;
            "console": "integratedTerminal",&#13;
            "cwd":"${fileDirname}", ## 解决执行路径问题&#13;
             //工作路径用打开的顶层目录，影响文件读写相对路径&#13;
            //"cwd": "${workspaceFolder}", &#13;
            //工作路径用当前文件所在目录，影响文件读写相对路径&#13;
            //"cwd": "${fileDirname}",&#13;
            //sys.path 会加入顶层目录，影响模块导入查询路径&#13;
            //"env": { "PYTHONPATH": "${workspaceFolder}" }&#13;
            }&#13;
        ],&#13;
        "compounds": []&#13;
    },&#13;
    "python.pythonPath": "/usr/local/anaconda3/envs/mrcnn/bin/python"&#13;
}&#13;
```&#13;
launch.json  &#13;
```JSON&#13;
{&#13;
    "version": "0.2.0",&#13;
    "configurations": [&#13;
&#13;
        {&#13;
            "name": "Python: base",&#13;
            "type": "python",&#13;
            "request": "launch",&#13;
            "program": "${file}",&#13;
            "console": "integratedTerminal",&#13;
            "pythonPath": "/usr/local/anaconda3/bin/python"&#13;
        },&#13;
        {&#13;
            "name": "Python: env",&#13;
            "type": "python",&#13;
            "request": "launch",&#13;
            "program": "${file}",&#13;
            "console": "integratedTerminal",&#13;
            "pythonPath": "~/env/bin/python"&#13;
        },&#13;
        {&#13;
            "name": "Python: mrcnn",&#13;
            "type": "python",&#13;
            "request": "launch",&#13;
            "program": "${file}",&#13;
            "console": "integratedTerminal",&#13;
            "pythonPath": "/usr/local/anaconda3/envs/mrcnn/bin/python"&#13;
        },&#13;
    ]&#13;
&#13;
}&#13;
```。</description><guid isPermaLink="true">https://evilvlso.github.io/post/vscode-zhong-python-huan-jing-pei-zhi-wen-jian.html</guid><pubDate>Tue, 02 Apr 2024 08:31:22 +0000</pubDate></item><item><title>Golang碎片化学习笔记</title><link>https://evilvlso.github.io/post/Golang-sui-pian-hua-xue-xi-bi-ji.html</link><description># Golang碎片化学习笔记&#13;
&#13;
- `counter := map[int]int{}  和 counter := make(map[int]int)`是等价的，直接上去{}初始化更装&#13;
&#13;
- 对slice，map进行for遍历，得到的值取决于用几个值接收&#13;
&#13;
  ```Golang&#13;
  for i,k := range slice  #i为索引  k为值&#13;
  for i := range slice # 则i仅为索引&#13;
  &#13;
  for k,v := range map  # key value都能取到&#13;
  for k := range map # 只有k&#13;
  ```&#13;
&#13;
- `make`创建的slice map 会初始化为该类型的零值，返回变量&#13;
&#13;
  ```Golang&#13;
  a:=make([]int,2)&#13;
  a[0]  #0 &#13;
  a[1]  # 0&#13;
  ```&#13;
&#13;
- `container/list`这是一个双向链表，他的主要方法有：&#13;
&#13;
  ```Golang&#13;
  l:=list.New()&#13;
  l.Front()&#13;
  l.Back()&#13;
  l.PushBack(你的数据)&#13;
  l.PushFront(你的数据)&#13;
  l.Remove(e) #e一定是他的Element类型 比如 l.Front 而不是你的数据  e.Value才是你的数据&#13;
  l.MoveFront(e) #e是Element类型 将要移动的数据&#13;
  l.MoveBack(e)&#13;
  ```&#13;
&#13;
&#13;
- 字符串遍历的结果是???&#13;
&#13;
  ```go&#13;
  a := "asdasf"&#13;
  for _, c := range a {&#13;
    fmt.Println(c)&#13;
  }&#13;
  #97&#13;
  115&#13;
  100&#13;
  97&#13;
  115&#13;
  102&#13;
  a := "够神呐虐"&#13;
  for _,i := range a {&#13;
    fmt.Println(i)&#13;
  }&#13;
  #&#13;
  22815&#13;
  31070&#13;
  21584&#13;
  34384&#13;
  ```&#13;
&#13;
- Slice取最后一个元素 索引不能是-1 &#13;
&#13;
  ```go&#13;
  	a := []int{}&#13;
  	fmt.Println(a[-1])  # must be a non-negtive&#13;
  	fmt.Println(a[len(a)-1])&#13;
  ```&#13;
&#13;
- `len()`获得的中文字符串长度不是你想的，获取的是字节长度&#13;
&#13;
  ```&#13;
  	a := "够神呐虐"&#13;
  	fmt.Println(len(a)) # 12 fuck&#13;
  	b := []rune(a)   # 4&#13;
  	b := []byte(a)  # 4  &#13;
  ```&#13;
&#13;
&#13;
-  **Printf、Sprintf、Fprintf区别**&#13;
&#13;
  # ![image-20220427171722010](https://raw.githubusercontent.com/evilvlso/picsbed/master/image-20220427171722010.png)&#13;
&#13;
- 小写变量在**本包内**可以访问&#13;
&#13;
- 字符串匹配&#13;
&#13;
- ```&#13;
  pattern []string&#13;
  pattern[0]=="a"  ??&#13;
  ```&#13;
&#13;
- 使用unicode筛选匹配中文&#13;
&#13;
 ```&#13;
  # 匹配所有汉字&#13;
  print(re.findall('[\u4e00-\u9fa5]', data))&#13;
 ```。</description><guid isPermaLink="true">https://evilvlso.github.io/post/Golang-sui-pian-hua-xue-xi-bi-ji.html</guid><pubDate>Tue, 02 Apr 2024 08:18:23 +0000</pubDate></item></channel></rss>